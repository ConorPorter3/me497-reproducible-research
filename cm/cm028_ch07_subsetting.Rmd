---
output: github_document
--- 

# subsetting 

```{r setup, echo = FALSE}
library(knitr)
opts_knit$set(root.dir = "../")
opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, collapse = FALSE, fig.keep = 'high')
```

```{r echo = FALSE}
# functions for text_icon and code_icon
source("cm/helper_02_icons.R")
```

- Please launch the `practiceR` project.  
- Open the  `chapter7.Rmd` script and continue adding to it from this tutorial. 

`r code_icon`  
```{r}
# packages 
library(plyr)
library(dplyr)
library(readr) 
library(tidyr)
library(stringr)
library(WDI)
library(ggplot2)
```


## subsetting we did in project 1 

We've seen quite a bit of subsetting activity already in Project 1.  

- `filter()` to subset a data frame by designated rows 

- `select()` to subset a data frame by designated columns 

- single brackets `[]` and double brackets `[[]]` as follows: 


In Project 1, you saw this next bit of code, 
```
    objects_to_subset <- c("coefficients", "residuals", "fitted.values")
    relevant_results  <- regr_results[objects_to_subset]
```

where we subsetted **regr_results** (a list of 12 named objects) using `[]`. We  extracted three objects named `"coefficients", "residuals", "fitted.values"` to create the **relevant_results** object.  

Also in Project 1, you saw these bits of code, 
```
    # extract the coefficients  
    coeff     <- relevant_results[['coefficients']] 
    
    # extract slope and intercept 
    slope     <- coeff[['input_lb']] 
    intercept <- coeff[['(Intercept)']] 
```

where we subsetted **relevant_results** using `[[]]` to extract **coeff** and and further subsetted **coeff** using `[[]]` to obtain the single values for **slope** and **intercept** of a regression.  

Again, in writing the report for Project 1, we had a data frame **results_df** that contained the results of the regression analysis that we wanted to use in the final report. 

```{r, echo=TRUE}
# itemized results that are cited in the report 
results_df <- read_csv('results/04_calibr_outcomes.csv') 
```

We converted that data frame to a list using `dlply`: 
```{r}
# specific numbers are easier to extract from a list
results_list <- dlply(results_df, 'item')
```

**results_list** is a list of data frames that includes a **slope** data frame with three entries: `item`, `num`, and `unit` (see the bottom of the list). 

```{r}
str(results_list)
```

We can use `$` subsets to extract the numerical value of the slope by:  

```{r}
# extract the slope data frame from results_list
slope_df <- results_list$slope

# extract the slope number from the slope_df data frame
slope    <- slope_df$num
```

Similarly, we used `$` subsetting to extract other  **results_list** numbers and units, e.g.,  
``` 
    # extract numbers from results_list 
    intercept   <- results_list$intercept$num  
    accuracy    <- results_list$accuracy$num  
    
    # extract units from results_list
    input_unit  <- results_list$input_min$unit 
    output_unit <- results_list$output_min$unit 
```


# subsetting by data values (7.1.5) 

We'll continue with the  `WDI` data frame we called **CompleteLongFert** last time. Here's a reminder of what that data frame looks like:

`r code_icon`  
```{r include=3, echo=FALSE}
library(readr)
CompleteLongFert <- read_csv("results/CompleteLongFert2.csv")
head(CompleteLongFert)
```


If we graph **fert_consump** using a probability density graph, we obtain: 

`r code_icon` 
```{r}
fig1 <- ggplot(CompleteLongFert, aes(fert_consump)) +
	geom_density() + 
	xlab("Fertilizer consumption (kg/hectare)") +
	ylab("Density")

print(fig1)
```

The graph shows that the data set has some extreme values, say greater than 1000 kg/hectare of arable land, that we might look at more closely to decide whether or not we should keep them in the data set. 

To subset the potential outliers, we use a logical test: 

`r code_icon` 
```{r}
FertOutliers <- CompleteLongFert %>%
	filter(fert_consump > 1000)
glimpse(FertOutliers)
```

What countries are these? Using a `$` subset and the `unique()` function: 

`r code_icon` 
```{r}
unique(FertOutliers$Country)
```

These countries have relatively small proportions of arable land, thus their fertilizer consumption per unit area of arable land is unsurprisingly high. 

To subset the data to omit these countries, we use a logical test again, bu this time we only keep those countries that have a consumption less than or equal to 1000. 

`r code_icon` 
```{r}
SubsetLongFert <- CompleteLongFert %>%
	filter(fert_consump <= 1000)
glimpse(SubsetLongFert)
```

Looking more closely at the rows of this data set, I find there are entries that are not actually countries. The following list, while not comprehensive, gives you an idea:  

```{r}
##  [30] "Caribbean small states"                              
##  [31] "Central Europe and the Baltics" 
##  [46] "Early-demographic dividend"   
##  [47] "East Asia & Pacific"    
##  [54] "Europe & Central Asia"                               
##  [55] "Europe & Central Asia (excluding high income)"       
##  [56] "Europe & Central Asia (IDA & IBRD countries)"   
##  [57] "European Union" 
##  [71] "Heavily indebted poor countries (HIPC)"              
##  [72] "High income"  
```

To create a subset of the data that omits these rows and retains rows for actual countries only, the first thing I want is a list of country codes only. 


I found an online data set of [country codes](http://www.iso.org/iso/home/standards/country_codes/country_names_and_code_elements_txt-temp.htm). 

To download this data set, I run the following lines just once, then comment them out. 


`r code_icon` 
```{r}
# url <- "http://www.iso.org/iso/home/standards/country_codes/country_names_and_code_elements_txt-temp.htm"
# destination <- "data/country_codes.txt"
# download.file(url, destination)
```


The data file is not a CSV file. If you open it you'll see that the data are separated by semicolons `;` --- no problem. That's what `readr::read_csv2()` is for. 

`r code_icon` 
```{r}
country_codes <- read_csv2("data/country_codes.txt")
head(country_codes)

# edit the column names
names(country_codes) <- c("country", "code")
head(country_codes)
```


Now I'll subset the column of codes:

`r code_icon` 
```{r}
these_are_countries <- country_codes$code
glimpse(these_are_countries)
```


And now I'll use these codes to subset the fertilizer data, keeping only those rows whose country codes match the **keep_these** list. 

`r code_icon` 
```{r}
Fert_Countries <- SubsetLongFert %>%
	filter(Abbr %in% these_are_countries)
glimpse(Fert_Countries)
```

- `%in%` returns a logical vector with TRUE indicating that an element of **Abbr** matches an element of **these_are_countries**. 
- The new data set with countries only has `r dim(Fert_Countries)[1]` rows compared to the `r dim(CompleteLongFert)[1]` we started with. 

Let's take a look at the distribution of the fertilizer consumption data now: 

`r code_icon` 
```{r}
fig2 <- ggplot(Fert_Countries, aes(fert_consump)) +
	geom_density() + 
	xlab("Fertilizer consumption (kg/hectare)") +
	ylab("Density")

print(fig2)
```





--- 
[main page](../README.md)
